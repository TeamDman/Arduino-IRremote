diff --git a/IRremote.cpp b/IRremote.cpp
index c9907eb..83f3aaf 100644
--- a/IRremote.cpp
+++ b/IRremote.cpp
@@ -120,17 +120,23 @@ int  MATCH_SPACE (int measured_ticks,  int desired_us)
 // As soon as first MARK arrives:
 //   Gap width is recorded; Ready is cleared; New logging starts
 //
-ISR (TIMER_INTR_NAME)
-{
+void IRInterrupt() {
 	TIMER_RESET;
 
 	// Read if IR Receiver -> SPACE [xmt LED off] or a MARK [xmt LED on]
 	// digitalRead() is very slow. Optimisation is possible, but makes the code unportable
+
+
+
+
+	
 	uint8_t  irdata = (uint8_t)digitalRead(irparams.recvpin);
 
+
 	irparams.timer++;  // One more 50uS tick
 	if (irparams.rawlen >= RAWBUF)  irparams.rcvstate = STATE_OVERFLOW ;  // Buffer overflow
 
+
 	switch(irparams.rcvstate) {
 		//......................................................................
 		case STATE_IDLE: // In the middle of a gap
@@ -181,13 +187,12 @@ ISR (TIMER_INTR_NAME)
 			irparams.rcvstate = STATE_STOP;
 		 	break;
 	}
-
-	// If requested, flash LED while receiving IR data
-	if (irparams.blinkflag) {
-		if (irdata == MARK)
-			if (irparams.blinkpin) digitalWrite(irparams.blinkpin, HIGH); // Turn user defined pin LED on
-				else BLINKLED_ON() ;   // if no user defined LED pin, turn default LED pin for the hardware on
-		else if (irparams.blinkpin) digitalWrite(irparams.blinkpin, LOW); // Turn user defined pin LED on
-				else BLINKLED_OFF() ;   // if no user defined LED pin, turn default LED pin for the hardware on
-	}
+	// // If requested, flash LED while receiving IR data
+	// if (irparams.blinkflag) {
+	// 	if (irdata == MARK)
+	// 		if (irparams.blinkpin) digitalWrite(irparams.blinkpin, HIGH); // Turn user defined pin LED on
+	// 			else BLINKLED_ON() ;   // if no user defined LED pin, turn default LED pin for the hardware on
+	// 	else if (irparams.blinkpin) digitalWrite(irparams.blinkpin, LOW); // Turn user defined pin LED on
+	// 			else BLINKLED_OFF() ;   // if no user defined LED pin, turn default LED pin for the hardware on
+	// }
 }
diff --git a/IRremote.h b/IRremote.h
index fe1a870..0461b3e 100644
--- a/IRremote.h
+++ b/IRremote.h
@@ -341,4 +341,6 @@ class IRsend
 #		endif
 } ;
 
+void IRInterrupt();
+
 #endif
diff --git a/boarddefs.h b/boarddefs.h
index 62b6be4..055c2b7 100644
--- a/boarddefs.h
+++ b/boarddefs.h
@@ -147,55 +147,64 @@
 //
 #if defined(IR_USE_TIMER2)
 
-#define TIMER_RESET
-#define TIMER_ENABLE_PWM    (TCCR2A |= _BV(COM2B1))
-#define TIMER_DISABLE_PWM   (TCCR2A &= ~(_BV(COM2B1)))
-#define TIMER_ENABLE_INTR   (TIMSK2 = _BV(OCIE2A))
-#define TIMER_DISABLE_INTR  (TIMSK2 = 0)
-#define TIMER_INTR_NAME     TIMER2_COMPA_vect
-
-#define TIMER_CONFIG_KHZ(val) ({ \
-	const uint8_t pwmval = SYSCLOCK / 2000 / (val); \
-	TCCR2A               = _BV(WGM20); \
-	TCCR2B               = _BV(WGM22) | _BV(CS20); \
-	OCR2A                = pwmval; \
-	OCR2B                = pwmval / 3; \
-})
-
-#define TIMER_COUNT_TOP  (SYSCLOCK * USECPERTICK / 1000000)
-
-//-----------------
-#if (TIMER_COUNT_TOP < 256)
-#	define TIMER_CONFIG_NORMAL() ({ \
-		TCCR2A = _BV(WGM21); \
-		TCCR2B = _BV(CS20); \
-		OCR2A  = TIMER_COUNT_TOP; \
-		TCNT2  = 0; \
-	})
-#else
-#	define TIMER_CONFIG_NORMAL() ({ \
-		TCCR2A = _BV(WGM21); \
-		TCCR2B = _BV(CS21); \
-		OCR2A  = TIMER_COUNT_TOP / 8; \
-		TCNT2  = 0; \
-	})
-#endif
-
-//-----------------
-#if defined(CORE_OC2B_PIN)
-#	define TIMER_PWM_PIN  CORE_OC2B_PIN  // Teensy
-#elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
-#	define TIMER_PWM_PIN  9              // Arduino Mega
-#elif defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__) \
-|| defined(__AVR_ATmega644__) || defined(__AVR_ATmega644P__) \
-|| defined(__AVR_ATmega324P__) || defined(__AVR_ATmega324A__) \
-|| defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega164A__) \
-|| defined(__AVR_ATmega164P__)
-#	define TIMER_PWM_PIN  14             // MightyCore
-#else
-#	define TIMER_PWM_PIN  3              // Arduino Duemilanove, Diecimila, LilyPad, etc
-#endif					     // ATmega48, ATmega88, ATmega168, ATmega328
-
+// #define TIMER_RESET
+// #define TIMER_ENABLE_PWM    (TCCR2A |= _BV(COM2B1))
+// #define TIMER_DISABLE_PWM   (TCCR2A &= ~(_BV(COM2B1)))
+// #define TIMER_ENABLE_INTR   (TIMSK2 = _BV(OCIE2A))
+// #define TIMER_DISABLE_INTR  (TIMSK2 = 0)
+// #define TIMER_INTR_NAME     TIMER2_COMPA_vect
+
+// #define TIMER_CONFIG_KHZ(val) ({ \
+// 	const uint8_t pwmval = SYSCLOCK / 2000 / (val); \
+// 	TCCR2A               = _BV(WGM20); \
+// 	TCCR2B               = _BV(WGM22) | _BV(CS20); \
+// 	OCR2A                = pwmval; \
+// 	OCR2B                = pwmval / 3; \
+// })
+
+// #define TIMER_COUNT_TOP  (SYSCLOCK * USECPERTICK / 1000000)
+
+// //-----------------
+// #if (TIMER_COUNT_TOP < 256)
+// #	define TIMER_CONFIG_NORMAL() ({ \
+// 		TCCR2A = _BV(WGM21); \
+// 		TCCR2B = _BV(CS20); \
+// 		OCR2A  = TIMER_COUNT_TOP; \
+// 		TCNT2  = 0; \
+// 	})
+// #else
+// #	define TIMER_CONFIG_NORMAL() ({ \
+// 		TCCR2A = _BV(WGM21); \
+// 		TCCR2B = _BV(CS21); \
+// 		OCR2A  = TIMER_COUNT_TOP / 8; \
+// 		TCNT2  = 0; \
+// 	})
+// #endif
+
+// //-----------------
+// #if defined(CORE_OC2B_PIN)
+// #	define TIMER_PWM_PIN  CORE_OC2B_PIN  // Teensy
+// #elif defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
+// #	define TIMER_PWM_PIN  9              // Arduino Mega
+// #elif defined(__AVR_ATmega1284__) || defined(__AVR_ATmega1284P__) \
+// || defined(__AVR_ATmega644__) || defined(__AVR_ATmega644P__) \
+// || defined(__AVR_ATmega324P__) || defined(__AVR_ATmega324A__) \
+// || defined(__AVR_ATmega324PA__) || defined(__AVR_ATmega164A__) \
+// || defined(__AVR_ATmega164P__)
+// #	define TIMER_PWM_PIN  14             // MightyCore
+// #else
+// #	define TIMER_PWM_PIN  3              // Arduino Duemilanove, Diecimila, LilyPad, etc
+// #endif					     // ATmega48, ATmega88, ATmega168, ATmega328
+#define TIMER_RESET 
+#define TIMER_ENABLE_PWM
+#define TIMER_DISABLE_PWM
+#define TIMER_ENABLE_INTR 
+#define TIMER_DISABLE_INTR 
+#define TIMER_INTR_NAME 
+#define TIMER_CONFIG_KHZ 
+#define TIMER_COUNT_TOP 
+#define TIMER_CONFIG_NORMAL() ({})
+#define TIMER_PWM_PIN 0
 //---------------------------------------------------------
 // Timer1 (16 bits)
 //
diff --git a/irRecv.cpp b/irRecv.cpp
index 6343856..fed6169 100644
--- a/irRecv.cpp
+++ b/irRecv.cpp
@@ -117,7 +117,8 @@ IRrecv::IRrecv (int recvpin, int blinkpin)
 //
 void  IRrecv::enableIRIn ( )
 {
-	cli();
+	// cli();
+	noInterrupts();
 	// Setup pulse clock timer interrupt
 	// Prescale /8 (16M/8 = 0.5 microseconds per tick)
 	// Therefore, the timer interval can range from 0.5 to 128 microseconds
@@ -129,7 +130,8 @@ void  IRrecv::enableIRIn ( )
 
 	TIMER_RESET;
 
-	sei();  // enable interrupts
+	// sei();  // enable interrupts
+	interrupts();
 
 	// Initialize state machine variables
 	irparams.rcvstate = STATE_IDLE;
